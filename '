#include <stdio.h>
#include <stdlib.h>
//A direction.
typedef enum {
  DIR_UP,
  DIR_RIGHT,
  DIR_DOWN,
  DIR_LEFT,
}dir_e;

//Cell state.
typedef enum {
  STATE_ALIVE,
  STATE_DEAD,
}cell_state_e;

//The main cell structure. Contains state, direction, and a pointer to the next cell (this is a linked list)
typedef struct {
  cell_state_e state; //The current state of this cell.
  int pos_x, pos_y;   //A cache of this cell's position in the grid.
  struct cell_t* next;       //A pointer to the next cell in the linked list.
}cell_t;

//The entire app's state.
typedef struct {
  struct grid_t {
    cell_t* first_cell; //The linked list of cells.
    int num_cells;      //The total number of cells, equal to size_x * size_y.

    size_t size_x, size_y; //Dimensions of the grid.
  }grid;
}state_t;


// FUNCTIONS

void dbg_print_cell(cell_t cell) {
  printf("Cell:\n");
  printf("\tState: %s\n", cell.state);
  printf("\tXpos: %d\n", cell.pos_x);
  printf("\tYpos: %d\n", cell.pos_y);
  printf("\tNext cell (pointer): %d\n", cell.next);
}

//Initializes the cell linked-list and grid, allocating it on the heap and giving a pointer to the first one. 
void init_grid(state_t* state, size_t size_x, size_t size_y) {
  cell_t* cell_alloc = (cell_t*)malloc(sizeof(cell_t) * size_x * size_y);

  if (cell_alloc == NULL) {
    perror("clife: failed to allocate space for cell grid");
    exit(1);
  }

  memset((void*)cell_alloc, 0, sizeof(cell_t) * size_x * size_y)

  //Safely assume that we have the linked list: time to set it up
  int arr_counter = 0;
  for (cell_t* cell = cell_alloc; cell != NULL; cell = cell->next) {
    if(arr_counter > size_x * size_y) break;
    cell->state = STATE_DEAD;
    cell->pos_x = arr_counter % size_x;
    cell->pos_y = arr_counter % size_y;

    arr_counter++;
  }

  //Finished initalizing it, time to give it back to the state
  state->grid.first_cell = cell_alloc;
  state->grid.num_cells = size_x * size_y;
  state->grid.size_x = size_x;
  state->grid.size_y = size_y;



}

//Destroys the cell linked list at the end of the program.
void destroy_cell_ll(state_t* state) {
  free(state->grid.first_cell);
}
//Initialize the program.
state_t* initialize(size_t size_x, size_t size_y) {
  state_t* state = (state_t*)0;

  //Initialize the grid
  init_grid(state, size_x, size_y);
  for(cell_t* cell = state->grid.first_cell; cell != NULL; cell = cell->next) {
      dbg_print_cell(*cell);    
  }

  return state;
}


//Cleanup everything after we're done
void clean_up(state_t* state) {
  destroy_cell_ll(state);
}


int main(int argc, char** argv) {
  state_t* state = initialize((size_t)8, (size_t)8);
  printf("We initialized!");
   
  printf("Hello World!!\n");
  return 0;
}
